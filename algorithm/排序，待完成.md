## 排序

**算法复杂度**

![image-20200904104458633](D:\work\notes\study\assert\image-20200904104458633.png)

### 冒泡排序

```c++
void bubble_sort(std::vector<int> &s)
{
    bool has_changed = true;
    int last_change = s.size() - 1;
    int pos = 0;                                          //pos变量用来标记循环里最后一次交换的位置
    for (int i = s.size() - 1; i > 0 && has_changed; i--) //一共要排序size-1次
    {
        has_changed = false;
        for (int j = 1; j <= last_change; j++)
        {
            if (s[j] < s[j - 1])
            {
                std::swap(s[j], s[j - 1]);
                has_changed = true;
                pos = j - 1;
            }
        }
        last_change = pos;
    }
}
```

这里对冒泡排序做了两个优化：

1. 若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。

2. 记住最后一次交换发生位置lastExchange的冒泡排序。在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。



### 选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

**算法步骤：**
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾

```c++
void selection_sort(std::vector<int> &s)
{
    for (int i = 0; i < s.size() - 1; i++)
    {
        int min_pos = i;
        for (int j = i + 1; j < s.size(); j++)
        {
            if (s[min_pos] > s[j])
            {
                min_pos = j;
            }
        }
        std::swap(s[i], s[min_pos]);
    }
}
```

**优化**

在每一次查找最小值的时候，也可以找到一个最大值，然后将两者分别放在它们应该出现的位置，这样遍历的次数就比较少了。代码中，第一次交换结束后，如果left那个位置原本放置的就是最大数，交换之后，需要将最大数的下标还原。 需要注意的是，每次记住的最小值或者最大值的下标，这样方便进行交换。

```cpp

void selection_sort2(std::vector<int> &s)
{
    int left = 0;
    int right = s.size() - 1;
    while (left < right)
    {
        int min = left;
        int max = right;
        for (int i = left + 1; i <= right; i++) // 这里要等于right
        {
            if (s[max] < s[i])
            {
                max = i;
            }

            if (s[min] > s[i])
            {
                min = i;
            }
        }
        std::swap(s[left], s[min]);
        std::swap(s[right], s[max]);

        left++;
        right--;
    }
}
```



### 插入排序

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

 算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

```c++
void insert_sort(std::vector<int> &s)
{
    for (int i = 1; i < s.size(); i++)
    {
        if (s[i] < s[i - 1])
        {
            int tmp = s[i];
            int j = i - 1;
            // 这里是将元素后移，最后在将tmp插入指定位置
            // 也可以直接通过交换的方法将指定的元素移到指定位置
            for (; j >= 0 && s[j] > tmp; j--)
            {
                s[j + 1] = s[j];
            }
            s[j + 1] = tmp;
        }
    }
}
```



### 希尔排序

希尔排序是在插入排序的基础上把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，就是在插入排序的最外层加入了一个步长递减的循环；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

量。

![img](D:\work\notes\study\assert\shell.png)

```c++
void shell_sort(std::vector<int> &s)
{
    for (int gap = s.size() / 2; gap > 0; gap /= 2)
    {
        for (int i = gap; i < s.size(); i++)
        {
            if (s[i] < s[i - gap])
            {
                int tmp = s[i];
                int j = i - gap;
                for (; j >= 0 && s[j] > tmp; j -= gap)
                {
                    s[j + gap] = s[j];
                }
                s[j + gap] = tmp;
            }
        }
    }
}
```



### 归并排序

算法描述

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

```c++


void merge_arry(std::vector<int> &s, int start, int mid, int end, std::vector<int> &tmp)
{
    int left = start;
    int right = mid + 1;
    int k = 0;
    while (left <= mid && right <= end)
    {
        if (s[left] < s[right])
        {
            tmp[k++] = s[left++];
        }
        else
        {
            tmp[k++] = s[right++];
        }
        // 也可以这样写
        // tmp[k++] = s[left] < s[right] ? s[left++] : s[right++];
    }
    while (left <= mid)
    {
        tmp[k++] = s[left++];
    }
    while (right <= end)
    {
        tmp[k++] = s[right++];
    }

    for (int i = 0; i < k; i++)
    {
        s[start + i] = tmp[i];
    }
}

void merge(std::vector<int> &s, int start, int end, std::vector<int> &tmp)
{
    if (start >= end)
    {
        return;
    }
    int mid = (start + end) / 2;
    merge(s, start, mid, tmp);
    merge(s, mid + 1, end, tmp);
    merge_arry(s, start, mid, end, tmp);
}

void merge_sort(std::vector<int> &s)
{
    std::vector<int> tmp;
    tmp.resize(s.size());
    merge(s, 0, s.size() - 1, tmp);
}
```

#### 非递归实现

非递归跟递归实现差不多一致，需要采用自底向上的进行归并，先让步长step从1开始，然后排序，最后依次将步长乘以2。

合并也是一样，需要找出开始start位置，中间mid位置，结束位置end，每次循环start从0开始，mid为start + step，end为mid + step。

最后需要注意end有可能超过数组的范围。

```c++

void merge_sort2(std::vector<int> &s)
{
    std::vector<int> tmp;
    tmp.resize(s.size());
    int step = 1;

    while (step < s.size())
    {
        int start = 0;
        while (start + step <= s.size() - 1)
        {
            int mid = start + step - 1;
            int end = mid + step;
            if (end > s.size() - 1)
            {
                end = s.size() - 1; //第二个序列个数不足step
            }
            merge_arry(s, start, mid, end, tmp);
            start = end + 1;
        }
        step *= 2;
    }
}
```



### 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

这里分区有两种方法，一种是直接从左到右；一种是先由右到左，在从左到右一直循环，直到找到位置。



```c++

int partition(std::vector<int> &s, int start, int end)
{
    int pos = start;
    for (int i = start + 1; i <= end; i++)
    {
        if (s[start] > s[i])
        {
            std::swap(s[++pos], s[i]);
        }
    }
    std::swap(s[pos], s[start]);
    return pos;
}

int partition2(std::vector<int> &s, int start, int end)
{
    int left = start;
    int right = end;
    int key = s[start];
    while (left < right)
    {
        while (right > left && s[right] > key)
        {
            right--;
        }
        if (right > left)
        {
            s[left++] = s[right];
        }

        while (right > left && s[left] <= key)
        {
            left++;
        }
        if (right > left)
        {
            s[right--] = s[left];
        }
    }
    s[left] = key;

    return left;
}

void partition_sort(std::vector<int> &s, int start, int end)
{
    if (start >= end)
    {
        return;
    }
    int pos = partition2(s, start, end);

    partition_sort(s, start, pos - 1);
    partition_sort(s, pos + 1, end);
}

void quick_sort(std::vector<int> &s)
{
    partition_sort(s, 0, s.size() - 1);
}
```



### 堆排序

堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
首先简单了解下堆结构:
堆是具有以下性质的完全二叉树：

- 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
- 对一个数组来说其最后一个非叶子节点为length / 2 -1。
- 对于一个i结点，其父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。

用简单的公式来描述一下堆的定义就是：

- 大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  
- 小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  



堆排序就是先从最后一个非叶子节点进行建堆，得到堆后将堆顶的元素与最后一个叶子节点进行交换，然后对破坏的堆重新进行调整，此时堆的大小减一。

```c++
void adjust_heap(std::vector<int> &s, int i, int len) // 这里的len由外面传进来，不能用数组的大小
{
    int tmp = s[i];
    for (int k = i * 2 + 1; k < len; k = k * 2 + 1) // 从i结点的左子结点开始，也就是2i+1处开始
    {
        if (k + 1 < len && s[k] < s[k + 1]) //如果左子结点小于右子结点，k指向右子结点, 这里主要是找子节点中值最大的一个
        {
            k++;
        }
        if (s[k] > tmp) //如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
        {
            s[i] = s[k];
            i = k;
        }
        else
        {
            break;
        }
    }
    s[i] = tmp; //将temp值放到最终的位置
}

void heap_sort(std::vector<int> &s)
{
    // 构建大顶堆
    //从第一个非叶子结点从下至上，从右至左调整结构
    for (int i = s.size() / 2 - 1; i >= 0; i--)
    {
        adjust_heap(s, i, s.size());
    }

    // 调整堆结构+交换堆顶元素与末尾元素
    for (int i = s.size() - 1; i > 0; i--)
    {
        std::swap(s[0], s[i]); //将堆顶元素与末尾元素进行交换
        adjust_heap(s, 0, i);  //重新对堆进行调整
    }
}
```



