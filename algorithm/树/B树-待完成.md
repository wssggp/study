从百科copy过来的相关定义

### 定义[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=12)]

根据 Knuth 的定义，一个 *m* 阶的B树是一个有以下属性的树：

1. 每一个节点最多有 *m* 个子节点
2. 每一个非叶子节点（除根节点）最少有 ⌈*m*/2⌉ 个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 *k* 个子节点的非叶子节点拥有 *k* − 1 个键
5. 所有的叶子节点都在同一层

每一个内部节点的键将节点的子树分开。例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键： *a*1 和 *a*2 。左边子树的所有值都必须小于 *a*1 ，中间子树的所有值都必须在 *a*1 和*a*2 之间，右边子树的所有值都必须大于 *a*2 。

- **内部节点**

  内部节点是除叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。每一个内部节点拥有最多 *U* 个，最少 *L* 个子节点。元素的数量总是比子节点指针的数量少一（元素的数量在 *L*-1 和 *U*-1 之间）。*U* 必须等于 2*L* 或者 2*L*-1;因此，每一个内部节点都至少是半满的。*U* 和 *L* 之间的关系意味着两个半满的节点可以合并成一个合法的节点，一个全满的节点可以被分裂成两个合法的节点（如果父节点有空间容纳移来的一个元素）。这些特性使得在B树中删除或插入新的值时可以调整树来保持B树的性质。

- **根节点**

  根节点拥有的子节点数量的上限和内部节点相同，但是没有下限。例如，当整个树中的元素数量小于 *L*-1 时，根节点是唯一的节点并且没有任何子节点。

- **叶子节点**

  叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。

一个深度为*n*+1 的B树可以容纳的元素数量大约是深度为 *n* 的B树的 *U* 倍，但是搜索、插入和删除操作的开销也会增加。和其他的平衡树一样，这一开销增加的速度远远慢于元素数量的增加。

一些平衡树只在叶子节点中存储值，而且叶子节点和内部节点使用不同的结构。B树在每一个节点中都存储值，所有的节点有着相同的结构。然而，因为叶子节点没有子节点，所以可以通过使用专门的结构来提高B树的性能。

## 算法[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=13)]

### 搜索[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=14)]

B树的搜索和二叉搜索树类似。从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

### 插入[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=15)]

[<img src="..\..\assert\B_tree_insertion_example.png" alt="img" style="zoom:80%;" />](https://zh.wikipedia.org/wiki/File:B_tree_insertion_example.png)

B树插入的例子。 节点最多有3个孩子 (Knuth 阶为 3).

所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：

1. 如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。
2. 否则的话这一节点已经满了，将它平均地分裂成两个节点：
   1. 从该节点的原有元素和新的元素中选择出中位数
   2. 小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。
   3. 分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。

如果分裂一直上升到根节点，那么一个新的根节点会被创建，它有一个分隔值和两个子节点。这就是根节点并不像内部节点一样有最少子节点数量限制的原因。每个节点中元素的最大数量是 *U*-1。当一个节点分裂时，一个元素被移动到它的父节点，但是一个新的元素增加了进来。所以最大的元素数量 *U*-1 必须能够被分成两个合法的节点。如果 *U*-1 是奇数，那么 *U*=2*L* ，总共有 2*L*-1 个元素，一个新的节点有 *L*-1 个元素，另外一个有 *L* 个元素，都是合法的节点。如果 *U*-1 是偶数，那么 *U*=2*L*-1,总共有 2*L*-2 个元素。 一半是 *L*-1，正好是节点允许的最小元素数量。

### 删除[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=16)]

有两种常用的删除策略

1. 定位并删除元素，然后调整树使它满足约束条件； **或者**
2. 从上到下处理这棵树，在进入一个节点之前，调整树使得之后一旦遇到了要删除的键，它可以被直接删除而不需要再进行调整

以下的算法使用了前一种策略。

删除一个元素时有以下两种特殊情况

1. 这个元素用于分隔一个内部节点的子节点
2. 删除元素会导致它所在的节点的元素或子节点数量小于最低值

下面分别是这些情况的处理过程

#### 删除叶子节点中的元素[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=17)]

1. 搜索要删除的元素
2. 如果它在叶子节点，将它从中删除
3. 如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树

#### 删除内部节点中的元素[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=18)]

内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：

1. 选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。
2. 前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。

#### 删除后的重新平衡[[编辑](https://zh.wikipedia.org/w/index.php?title=B树&action=edit&section=19)]

重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 **合并**。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：[[来源请求\]](https://zh.wikipedia.org/wiki/Wikipedia:列明来源)

- 如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转
  1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转
  1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
  1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）
  2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）
  3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
     - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
     - 否则，如果父节点的元素数量小于最小值，重新平衡父节点



另外可以看下这个博客https://blog.csdn.net/zycxnanwang/article/details/105384618

https://blog.csdn.net/Linux_ever/article/details/51394055